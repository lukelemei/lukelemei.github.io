<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://https://github.com/lukelemei/lukelemei.github.io</id>
    <title>浩玩技术栈</title>
    <updated>2020-03-10T12:05:31.703Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://https://github.com/lukelemei/lukelemei.github.io"/>
    <link rel="self" href="https://https://github.com/lukelemei/lukelemei.github.io/atom.xml"/>
    <subtitle>结合博主自身经验，专注分享运维技术文章！</subtitle>
    <logo>https://https://github.com/lukelemei/lukelemei.github.io/images/avatar.png</logo>
    <icon>https://https://github.com/lukelemei/lukelemei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 浩玩技术栈</rights>
    <entry>
        <title type="html"><![CDATA[Django Web开发入门（一）]]></title>
        <id>https://https://github.com/lukelemei/lukelemei.github.io/post/django-web-kai-fa-ru-men-yi/</id>
        <link href="https://https://github.com/lukelemei/lukelemei.github.io/post/django-web-kai-fa-ru-men-yi/">
        </link>
        <updated>2020-03-10T12:04:15.000Z</updated>
        <content type="html"><![CDATA[<h4 id="安装">安装</h4>
<pre><code>pip3 install django==2.2.11 指定版本安装
pip3 install django 不指定版本即安装最新版本，目前是3.0.4
在python中导入django模块，能正确打印出版本，即安装成功
PyDev console: starting.
Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 16:52:21) 
[Clang 6.0 (clang-600.0.57)] on darwin
import django
print(django.VERSION)
(2, 2, 11, 'final', 0)
</code></pre>
<h4 id="建立项目">建立项目</h4>
<ul>
<li>命令:</li>
</ul>
<pre><code>django-admin startproject myproject 项目名称
项目建成后，目录树如下
├── manage.py
└── myproject
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
</code></pre>
<h4 id="建立应用">建立应用</h4>
<ul>
<li>命令：</li>
</ul>
<pre><code>python manage.py startapp myapp 应用名称
应用建成后，目录树如下：
.
├── __init__.py
├── admin.py
├── apps.py
├── migrations
│   └── __init__.py
├── models.py
├── tests.py
└── views.py
</code></pre>
<h4 id="编写页面应用代码">编写页面应用代码</h4>
<ul>
<li>路由响应函数</li>
<li>通过url将用户http访问与路由函数进行绑定</li>
<li>在myproject/urls.py文件中，加入应用的urls.py的引用</li>
</ul>
<h4 id="范例演示">范例演示</h4>
<p>演示一个简单的页面</p>
<ul>
<li>第一步：在myproject/myapp/views.py中建立路由响应函数</li>
</ul>
<pre><code>from django.shortcuts import render
from django.http import HttpResponse
# Create your views here.
def welcome(request):
	return HttpResponse(&quot;&lt;h1&gt;welcome to my first web!&lt;/h1&gt;&quot;)
</code></pre>
<ul>
<li>第二步：通过URL将用户的http访问与路由函数绑定<br>
在myproject/myapp 目录中，新建一个urls.py文件，管理应用的所有url映射</li>
</ul>
<pre><code>from django.conf.urls import url
from . import views

urlpatterns = [
	url(r'',views.welcome,name='first-url'),
]
</code></pre>
<ul>
<li>第三步：在myproject/urls.py文件中，添加一行，声明对应用myapp的urls.py文件的引用</li>
</ul>
<pre><code>from django.contrib import admin
from django.urls import path
from django.conf.urls import url  #本行为新增
from django.conf.urls import include  #本行为新增
urlpatterns = [
	url(r'^app/',include('myapp.urls')),  #本行为新增
    path('admin/', admin.site.urls),
]
</code></pre>
<h4 id="启动页面访问">启动页面访问</h4>
<p>通过内置的web服务器访问页面，仅用于开发测试环境</p>
<ul>
<li>命令：</li>
</ul>
<pre><code>python manage.py runserver 0:8002
</code></pre>
<p>如无报错，页面显示如下：<br>
<a href="https://imgchr.com/i/8ifL79"><img src="https://s2.ax1x.com/2020/03/10/8ifL79.md.jpg" alt="8ifL79.md.jpg" loading="lazy"></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[玩转 Docker（二）]]></title>
        <id>https://https://github.com/lukelemei/lukelemei.github.io/post/wan-zhuan-dockerer/</id>
        <link href="https://https://github.com/lukelemei/lukelemei.github.io/post/wan-zhuan-dockerer/">
        </link>
        <updated>2020-03-05T12:47:13.000Z</updated>
        <content type="html"><![CDATA[<h4 id="docker-网络">Docker 网络</h4>
<ul>
<li>应用对外访问</li>
</ul>
<pre><code>-P:在49000-49900之间，随机映射一个端口
-p：手动指定端口，宿主机的3303:3000（外部）
</code></pre>
<ul>
<li>容器间网络通信</li>
</ul>
<pre><code>使用 --link参数
创建一个数据库容器：
docker run -d –namemysqldb mysql:5.6
创建一个web容器并和数据库容器建立连接：
docker run -d –name Webapp–p 8000:8080 –link mysqldb:MySQL tomcat
上边的MySQL别名就类似dns解析的方式，我给这个容器起了个别名叫MySQL，我就通过这个别名就可以找到对应的这个mysqldb容器
mysqldb容器和web容器建立互联关系。
</code></pre>
<h4 id="dockerfile">Dockerfile</h4>
<p>Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义镜像。</p>
<ul>
<li>参数解释</li>
</ul>
<pre><code>FROM
格式：FROM&lt;image&gt;或FROM&lt;image&gt;:&lt;tag&gt;。
解释：FROM是Dockerfile里的第一条指令（必须是），后面跟有效的镜像名（如果该镜像你的本地仓库没有则会从远程仓库Pull取）。然后后面的其它指令FROM的镜像中执行。

MAINTAINER
格式：MAINTAINER &lt;name&gt;
解释：指定维护者信息。

RUN
格式：RUN &lt;command&gt;或 RUN[&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]。
解释：运行命令，命令较长使可以使用\来换行。推荐使用上面数组的格式

CMD
格式：
CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 使用 exec 执行，推荐方式；
CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；
CMD [&quot;param1&quot;,&quot;param2&quot;] 提供给ENTRYPOINT的默认参数；
解释：
CMD指定容器启动是执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条，只有最后一条会被执行。如果你在启动容器的时候也指定的命令，那么会覆盖Dockerfile构建的镜像里面的CMD命令。

ENTRYPOINT
格式：
   ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;,&quot;param2&quot;]
   ENTRYPOINT command param1 param2（shell中执行）。
解释：和CMD类似都是配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。
每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。ENTRYPOINT没有CMD的可替换特性，也就是你启动容器的时候增加运行的命令不会覆盖ENTRYPOINT指定的命令。
所以生产实践中我们可以同时使用ENTRYPOINT和CMD，
例如：
ENTRYPOINT [&quot;/usr/bin/rethinkdb&quot;]
CMD [&quot;--help&quot;]

USER
格式：USER daemon
解释：指定运行容器时的用户名和UID，后续的RUN指令也会使用这里指定的用户。

EXPOSE
格式：EXPOSE&lt;port&gt; [&lt;port&gt;...]
解释：设置Docker容器内部暴露的端口号，如果需要外部访问，还需要启动容器时增加-p或者-P参数进行分配。

ENV
格式：ENV 
ENV =&lt;value&gt; ...
解释：设置环境变量，可以在RUN之前使用，然后RUN命令时调用，容器启动时这些环境变量都会被指定

ADD
格式：
   ADD &lt;src&gt;... &lt;dest&gt;
ADD [&quot;&quot;,... &quot;&quot;]
解释：将指定的复制到容器文件系统中的
所有拷贝到container中的文件和文件夹权限为0755,uid和gid为0
如果文件是可识别的压缩格式，则docker会帮忙解压缩

VOLUME
格式：VOLUME [&quot;/data&quot;]
解释：可以将本地文件夹或者其他container的文件夹挂载到container中。

WORKDIR
格式：WORKDIR/path/to/workdir
解释：切换目录，为后续的RUN、CMD、ENTRYPOINT 指令配置工作目录。
可以多次切换(相当于cd命令)，
也可以使用多个WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如

WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
则最终路径为 /a/b/c。
ONBUILD
ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行

ARG
格式：ARG&lt;name&gt;[=&lt;default value&gt;]
解释：ARG指定了一个变量在docker build的时候使用，可以使用--build-arg =来指定参数的值，不过如果构建的时候不指定就会报错。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[玩转 Docker（一）]]></title>
        <id>https://https://github.com/lukelemei/lukelemei.github.io/post/wan-zhuan-dockeryi/</id>
        <link href="https://https://github.com/lukelemei/lukelemei.github.io/post/wan-zhuan-dockeryi/">
        </link>
        <updated>2020-03-05T12:39:30.000Z</updated>
        <content type="html"><![CDATA[<h4 id="虚拟化与docker">虚拟化与docker</h4>
<ul>
<li>
<p>虚拟化定义：虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。</p>
</li>
<li>
<p>系统虚拟化，Hypervisor Virtualization，全虚拟化。在 Host 中通过 Hypervisor 层实现安装多个 GuestOS，每个 GuestOS 都有自己的内核，和主机的内核不同，GuestOS 之间完全隔离。</p>
</li>
<li>
<p>容器虚拟化，Operating System Virtualization ，使用 Linux 内核中的 namespaces 和 cgroups 实现进程组之间的隔离。是用内核技术实现的隔离，所以它是一个共享内核的虚拟化技术。</p>
</li>
<li>
<p>容器虚拟化没有 GuestOS，使用 Docker 时下载的镜像，只是为运行 App 提供的一个依赖的环境，是一个删减版本的系统镜像。一般情况下系统虚拟化没有容器虚拟化的运行效率高，但是系统安全性高很多。</p>
</li>
</ul>
<h4 id="核心概念">核心概念</h4>
<ul>
<li>镜像： 镜像就是一个只读的模板</li>
<li>容器：运行应用。可以把容器看成一个精简版的Linux环境</li>
<li>仓库：集中存放镜像文件的地方。</li>
</ul>
<h4 id="docker常用命令-镜像">Docker常用命令-镜像</h4>
<ul>
<li>获取镜像：docker pull</li>
<li>查看镜像列表：docker images</li>
<li>查看镜像信息：docker inspect</li>
<li>查找镜像：docker search</li>
<li>删除镜像：docker rmi</li>
<li>创建镜像：docker commit</li>
<li>导出镜像：docker save [images] &gt; [name.tar]（可以导出多个镜像合成一个tar包）</li>
<li>导入镜像：docker load &lt; xxx.tar</li>
<li>上传镜像：docker push</li>
</ul>
<h4 id="docker常用命令-容器">Docker常用命令-容器</h4>
<ul>
<li>启动容器：docker run –name -h hostname</li>
</ul>
<pre><code>docker run -d -P nginx

-d运行在后台

-P 代表随机映射

nginx 镜像的名称
</code></pre>
<ul>
<li>
<p>停止容器：docker stop CONTAINER ID</p>
</li>
<li>
<p>查看容器：docker ps -a -l</p>
</li>
<li>
<p>进入容器：docker exec | docker attach |nsenter</p>
</li>
<li>
<p>删除容器：docker rm</p>
</li>
<li>
<p>查看容器日志：docker logs CONTAINER ID</p>
</li>
</ul>
<h4 id="docker-仓库">Docker 仓库</h4>
<ul>
<li>公有仓库：在互联网上，任何人都可以访问
<ul>
<li><a href="https://hub.docker.com/">docker hub</a> 官方仓库</li>
<li><a href="https://dev.aliyun.com/search.html">阿里云</a></li>
<li><a href="https://c.163yun.com/hub#/m/home/">网易云</a></li>
<li><a href="https://hub.daocloud.io/">DaoCloud</a></li>
</ul>
</li>
<li>私有仓库：个人或者组织的私有仓库，只有有访问权限的人才可访问</li>
<li>开源企业级镜像仓库平台：<a href="https://goharbor.io">Harbor</a></li>
</ul>
<h4 id="镜像加速站">镜像加速站</h4>
<ul>
<li>官方默认的镜像仓库在国外，拉取镜像太慢，可配置国内加速器进行加速</li>
<li>国内加速站点</li>
</ul>
<pre><code>https://registry.docker-cn.com

http://hub-mirror.c.163.com

https://3laho3y3.mirror.aliyuncs.com

http://f1361db2.m.daocloud.io

https://mirror.ccs.tencentyun.com
</code></pre>
<ul>
<li>加速配置范例</li>
</ul>
<pre><code>没有daemon.json文件，则需新建
vim /etc/docker/daemon.json 
写入
{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}
systemctl daemon-reload
systemctl restart docker
镜像加速可以设置多个，之间用逗号隔开
</code></pre>
<h4 id="docker-网络">Docker 网络</h4>
<p>Docker网络目前有四种网络模式：Bridge模式、Host模式、Container模式、None模式</p>
<ul>
<li>Bridge：容器启动后默认的网络模式。</li>
</ul>
<pre><code>当Docker进程启动时，会在主机上创建一个名为Docker0的虚拟网桥，此主机上启动的Docker容器默认会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机相似，这样主机上的所有容器就通过交换机连在了一个二层网络中。从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0(容器内部网卡)，另一端在放在主机中，以vethxxx这样类似的名称命名，并将这个网络设备加入到docker0网桥中。可以使用brctl show命令查看
</code></pre>
<ul>
<li>Host：容器和宿主机共用一个网络</li>
</ul>
<pre><code>如果启动容器的时候使用host模式，那么这个容器将不会获取一个独立的Network Namespace，而是和宿主机共用一个Network Namespace(这里和我们平常使用的虚拟机的仅主机模式相似)。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、系统进程等还是和宿主机隔离的
</code></pre>
<ul>
<li>Container: 新建容器和已有容器共用一个网络，不和宿主机共享网络</li>
</ul>
<pre><code>这个模式指定新创建的容器和已经存在的容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器也不会自己创建网卡，IP等。而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的还都是属于隔离。两个容器的进程可以通过宿主机的lo网卡设备进行通信
</code></pre>
<ul>
<li>None：容器只用自己的独有网络</li>
</ul>
<pre><code>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等
</code></pre>
<h4 id="docker-数据管理">Docker 数据管理</h4>
<ul>
<li>数据卷</li>
</ul>
<pre><code>数据卷是一个可供容器或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性 （相当于NFS）,其目的是用于数据的持久化。

1. 数据卷可以在容器之间共享和重用
2. 对数据卷的修改会马上生效
3. 对数据卷的更新，不会影响镜像
4. 数据卷默认会一直存在，即使容器被删除

数据卷的使用，类似于NFS挂载，镜像中的被指定为挂载点的目录中会隐藏掉，能显示看 的是挂载的数据卷
</code></pre>
<ul>
<li>数据卷相关命令：</li>
</ul>
<pre><code>创建数据卷：docker volume create data
查看所有数据卷：docker volume ls
查看指定数据卷信息：docker volume inspect data
挂载数据卷：docker run -v参数进行指定
数据卷的默认权限为rw（可读写），如要改变需要手动指定，例如改为ro只读：docker run -d –name app1-it -v /webapp:/root/webapp:ro ubuntu bash
</code></pre>
<ul>
<li>数据卷容器<br>
命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的这个容器成为数据卷容器。</li>
</ul>
<pre><code>Example:

创建数据卷容器db1

docker run -d –name db1 -v/dbdata -ti ubuntu bash

创建容器db2与db1共享dbdata的数据

docker run -d –name db2 –volumes-from db1 -ti ubuntu bash

在容器db1和容器db2任意一个容器修改dbdata的内容，在两个容器内均生效


</code></pre>
<p>用数据卷容器备份和恢复数据</p>
<ul>
<li>备份：</li>
</ul>
<pre><code>[root@tcy1 Documents]# docker run --volumes-from volume-test1 -v $(pwd):/backup --name volume-test6 nginx tar cvf /backup/backup.tar /data
tar: Removing leading `/' from member names
/data/
/data/test/
/data/testSyc

命令解释：

①、首先利用nginx镜像创建了一个名字为volume-test6的容器；
②使用 --volumes-from volume-test1参数让volume-test6容器挂载volume-test1容器中的data数据卷；
③使用 -v $(pwd):/backup参数来挂载本地的当前目录到volume-test1容器的/backup目录。
④volume-test1容器启动后，使用tar cvf /backup/backup.tar /data命令来将 /data下内容备份为容器内的/backup/backup.tar,即宿主机当前目录下的backup.tar。
</code></pre>
<ul>
<li>恢复：</li>
</ul>
<pre><code>将数据恢复到一个容器:
①创建一个带有数据卷datarecover的容器recover，
[root@tcy1 Documents]# docker run -v /datarecover --name recover nginx
②创建另一个新的容器，挂载数据卷datarecover，然后解压备份文件到所挂载的容器卷中。
[root@tcy1 tcy]# docker run --volumes-from recover -v $(pwd):/backup nginx tar xvf /backup/backup.tar
data/
data/test/
data/testSyc
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS6.X 安装zabbix-agent]]></title>
        <id>https://https://github.com/lukelemei/lukelemei.github.io/post/centos6x-an-zhuang-zabbix-agent/</id>
        <link href="https://https://github.com/lukelemei/lukelemei.github.io/post/centos6x-an-zhuang-zabbix-agent/">
        </link>
        <updated>2020-03-03T13:32:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.安装zabbix-agent</strong></p>
<p>rpm -ivh zabbix-agent-4.0.14-1.el7.x86_64.rpm</p>
<p><strong>2.修改</strong>**/etc/zabbix/zabbix_agentd.conf文件：**</p>
<p><strong>执行如下命令</strong></p>
<p>sed -i 's/Server=127.0.0.1/Server=35.1.196.100/g' /etc/zabbix/zabbix_agentd.conf</p>
<p>sed -i 's/ServerActive=127.0.0.1/ServerActive=35.1.196.100/g' /etc/zabbix/zabbix_agentd.conf</p>
<p>执行完成后，打开文件检查下 Server和ServerActive两个选项的IP是否已经修改为35.1.196.100</p>
<p><strong>3.启动服务并设置为开启启动</strong></p>
<p>service zabbix-agent start 启动服务</p>
<p>chkconfig zabbix-agent on 开启启动</p>
<p><strong>4.如果已经开启防火墙，需在防火墙放行10050端口，未开启防火墙请忽略</strong></p>
<p>放行端口命令：<br>
iptables -A INPUT -p tcp --dport 10050 -j ACCEPT<br>
<strong>5.关闭selinux</strong></p>
<p>执行命令：setenforce 0(立即生效)</p>
<p>并修改配置文件/etc/selinux/config 将selinux设置为disabled(重启后，永久生效)</p>
]]></content>
    </entry>
</feed>